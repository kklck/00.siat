--17.PLSQLFunction.sql
/*
1.저장 함수(Function)
	-오라클 사용자 정의 함수 

2.문법
	create OR REPLACE function 함수명
	return 리턴타입 --프로시저와 다른 점
	is
	begin
	end;
	/
	
3.주의
	-절대 기존 함수명들과 중복 불가
	-참고
		함수 종류 : 내장 함수 & 사용자 정의 함수
		
4.프로시저와 차이
	-선언구
	-리턴 타입 선언 + 리턴 값
	-return 키워드 활용
*/


--1.emp table의 사번으로 사원 이름 검색 함수 
CREATE OR REPLACE FUNCTION USER_FUNC(NO NUMBER)
RETURN VARCHAR2
IS
    V_ENAME EMP.ENAME%TYPE;
BEGIN
    SELECT ENAME
    INTO V_ENAME
    FROM EMP
    WHERE EMPNO = NO;
    
    RETURN V_ENAME;
END;
/

SELECT USER_FUNC(7369)
FROM DUAL;--EMP 테이블은 값이 12개 나옴

--2.?%type 사용해서 사원명으로 해당 사원의 job 반환 함수 
--함수명 : emp_job
CREATE OR REPLACE FUNCTION EMP_JOB(V_ENAME EMP.ENAME%TYPE)
RETURN EMP.ENAME%TYPE
IS
    V_JOB EMP.JOB%TYPE;
BEGIN
    SELECT JOB
    INTO V_JOB
    FROM EMP
    WHERE ENAME = V_ENAME;
    
    RETURN V_JOB;
END;
/
SELECT EMP_JOB('SMITH')
FROM DUAL;

--3.?특별 보너스를 지급 함수
--급여 200% 인상해서 지급(sal*2)
--함수명 : cal_bonus
CREATE OR REPLACE FUNCTION CAL_BONUS(V_EMPNO EMP.EMPNO%TYPE)
RETURN EMP.SAL%TYPE
IS
    V_SAL EMP.SAL%TYPE;
BEGIN
    SELECT SAL
    INTO V_SAL
    FROM EMP
    WHERE EMPNO = V_EMPNO;
    
    RETURN V_SAL*2;
END;
/

SELECT CAL_BONUS(&V)
FROM DUAL;

--4.?부서 번호를 입력 받아 최고 급여액을 반환하는 함수
--함수명 : s_max_sal

CREATE OR REPLACE FUNCTION S_MAX_SAL(V_DEPTNO EMP.DEPTNO%TYPE)
RETURN EMP.SAL%TYPE
IS
    V_SAL EMP.SAL%TYPE;
BEGIN
    SELECT MAX(SAL)
    INTO V_SAL
    FROM EMP
    WHERE DEPTNO = V_DEPTNO;
    
    RETURN V_SAL;
END;
/

SELECT S_MAX_SAL(10)
FROM DUAL;


--5.?부서 번호를 입력 받아 부서 평균 급여를 구해주는 함수
--함수명 : avg_sal
CREATE OR REPLACE FUNCTION AVG_SAL(V_DEPTNO EMP.DEPTNO%TYPE)
RETURN EMP.SAL%TYPE
IS
    V_SAL EMP.SAL%TYPE;
BEGIN
    SELECT AVG(SAL)
    INTO V_SAL
    FROM EMP
    WHERE DEPTNO = V_DEPTNO;
    
    RETURN V_SAL;
END;
/
SELECT AVG_SAL(20)
FROM DUAL;
--그룹바이 써보기
CREATE OR REPLACE FUNCTION AVG_SAL_G(V_DEPTNO EMP.DEPTNO%TYPE)
RETURN EMP.SAL%TYPE
IS
    V_SAL EMP.SAL%TYPE;
BEGIN
    SELECT AVG(SAL)
    INTO V_SAL
    FROM EMP
    GROUP BY DEPTNO
    HAVING DEPTNO = V_DEPTNO;
    
    RETURN V_SAL;
END;
/
SELECT AVG_SAL_G(20)
FROM DUAL;

--6.존재하는 함수 삭제 명령어
--drop funcation 함수명;
DROP FUNCTION AVG_SAL_G;


--7.함수 내용 검색
DESC USER_SOURCE;
SELECT TEXT FROM USER_SOURCE WHERE TYPE='FUNCTION';


--8.dept에 새로운 데이터 저장 함수
--함수명 : insert_dept
--dup_val_on_index : exception 활용
/*
--1. 필요 SQL : INSERT INTO DEPT VALUES (?, ?, ?);
--2. 실행
        - 정상 실행
            삽입 완료
        - 비정상 오류
            - 컴파일 오류
            - 런타입 오류
            - PK중복 에러
                - 입력한 대로 데이터 값 +1;
                - MAX -> +1

*/
CREATE OR REPLACE PROCEDURE INSERT_DEPT(
    V_DEPTNO DEPT.DEPTNO%TYPE,
    V_DNAME DEPT.DNAME%TYPE,
    V_LOC DEPT.LOC%TYPE
    )
IS
BEGIN
    INSERT INTO DEPT VALUES (V_DEPTNO, V_DNAME, V_LOC);
    EXCEPTION
        WHEN dup_val_on_index THEN
            INSERT INTO DEPT VALUES (V_DEPTNO+1, V_DNAME, V_LOC);            
END;
/

SELECT * FROM DEPT;
EXECUTE INSERT_DEPT(40, 'SIAT', 'PANGYO');--두번 하면 안됌
--step01
CREATE OR REPLACE FUNCTION INSERT_DEPT2(
    V_DEPTNO DEPT.DEPTNO%TYPE,
    V_DNAME DEPT.DNAME%TYPE,
    V_LOC DEPT.LOC%TYPE
    )
RETURN DEPT.DEPTNO%TYPE
IS
    PRAGMA AUTONOMOUS_TRANSACTION;
    V_MAX_DEPTNO DEPT.DEPTNO%TYPE;
BEGIN
    BEGIN
        INSERT INTO DEPT VALUES (V_DEPTNO, V_DNAME, V_LOC);
        COMMIT;
        RETURN V_DEPTNO;
      
        EXCEPTION
        WHEN dup_val_on_index THEN
            SELECT MAX(DEPTNO)
            INTO V_MAX_DEPTNO
            FROM DEPT;
            V_MAX_DEPTNO := V_MAX_DEPTNO + 10;
    END;
    BEGIN
            INSERT INTO DEPT VALUES (V_MAX_DEPTNO, V_DNAME, V_LOC);
            COMMIT;
            RETURN V_MAX_DEPTNO;
    END;
END;
/
--PRAGMA : 독자적 수행 가능
SELECT INSERT_DEPT2(40, 'SIAT2','MIGEUM')
FROM DUAL;
SELECT INSERT_DEPT2(80, 'SIAT3','BUCHEON')
FROM DUAL;

SELECT * FROM DEPT;

ROLLBACK;

DELETE FROM DEPT WHERE DEPTNO = 60;
SELECT MAX(DEPTNO)
FROM DEPT;

--step02
--STEP02
CREATE OR REPLACE FUNCTION INSERT_DEPT3
(V_DEPTNO DEPT.DEPTNO%TYPE, 
 V_DNAME DEPT.DNAME%TYPE, 
 V_LOC DEPT.LOC%TYPE)
RETURN DEPT.DEPTNO%TYPE
IS
   PRAGMA AUTONOMOUS_TRANSACTION;
   V_TMP DEPT.DEPTNO%TYPE;
BEGIN
   BEGIN
      INSERT
         INTO DEPT VALUES(V_DEPTNO, V_DNAME, V_LOC);
         COMMIT;
         RETURN V_DEPTNO;
         EXCEPTION
            WHEN DUP_VAL_ON_INDEX THEN
               SELECT MAX(DEPTNO)
                  INTO V_TMP
                  FROM DEPT;
               V_TMP := V_TMP + 10;
   END;
   BEGIN
      INSERT
         INTO DEPT VALUES(V_TMP, V_DNAME, V_LOC);
      COMMIT;
      RETURN V_TMP;
   END;
END;
/

SELECT INSERT_DEPT3(60, 'A', 'B') FROM DUAL;
SELECT INSERT_DEPT3(60, 'A', 'B') FROM DUAL;

SELECT * FROM DEPT;

DELETE FROM DEPT WHERE DEPTNO = 60;
