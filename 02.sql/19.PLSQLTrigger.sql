--19.PLSQLTrigger.sql
/*
1.트리거(TRIGGER)
	- PLSQL 블록, 특정 이벤트가 발생할 경우 연관된 작업을 수행
    - 여기서 이벤트는 테이블의 변화를 의미

2.TRIGGER 구조
	-구성 
		실행시점(TIMING)
        사건(EVENT)
        영향 TABLE/VIEW/TRIGGER...
        BODY 

	-문법
		CREATE [OR REPLACE] TRIGGER TRIGGER명
		TIMING
			EVENT 1[ OR EVENT2 OR ...]
		ON 
			TABLE명 OR VIEW명 (이벤트 등록 TABLE명)
		[REFERENCING OLD OR NEW]
		[FOR EACH ROW] -- 모든 행에 대한 검증
			TRIGGER BODY
	
	-TIMING : TRIGGER가 실행되는 시점 지정, EVENT 발생 전 혹은 후를 의미
        - BEFORE
        - AFTER
        
3.참고
	-OLD : SELECT 데이터, :OLD (옛날값을 표기하는 용어로는 콜론) 
	-NEW : 지정한 데이터, :NEW
    
-- TRIGGER진행시 권한 부여 필요

*/

--TRIGGER 생성 변경 삭제 권한 부여


--1.입력 시간 제한 TRIGGER : 특정 시간 안에서만 테이블을 사용할 수 있는 기능
DROP TABLE ORDER_TABLE;

CREATE TABLE ORDER_TABLE(
	NO NUMBER,
	ORD_CODE VARCHAR2(10),
	ORD_DATE DATE
);


--구성
--RAISE_APPLICATION_ERROR( [에러코드], [에러메시지] )
--에러코드 : -20000 ~ -20999 사이의 코드 (-20300 무효한 제품 코드) -- 사용자 정의시 필요한 코드
/* 트리거를 만들기전에 미리 구상하기
    - 오전 10~12시 저장되는 INSERT만 허용
    - 10:00 ~ 12:00
    - 24HH:MI
    - SYSDATE -> 가공 (TO_CHAR(SYSDATE, 'HH24:MI')) -> 10:00
*/

DROP TRIGGER TIME_ORDER;

CREATE OR REPLACE TRIGGER TIME_ORDER
BEFORE INSERT --인설트 오면 조건을 보자
ON
    ORDER_TABLE-- 이 테이블에 말야
BEGIN
    IF(TO_CHAR(SYSDATE, 'HH24:MI') NOT BETWEEN '09:00' AND '20:00') THEN
        RAISE_APPLICATION_ERROR(-20100, '허용시간 아님');
    END IF;
END;
/

INSERT INTO ORDER_TABLE VALUES(1, 'C001', SYSDATE);
SELECT * FROM ORDER_TABLE;
SELECT * FROM TIME_ORDER;

--2.입력값 제한 TRIGGER
-- ORD_CODE 컬럼에 'C001'데이터를 제외한 나머지는 입력불가
-- INSERT에 새로운 데이터 값 : NEW.ORD_CODE
-- 조건식

DROP TRIGGER DATA_FILTER_ORDER;

CREATE OR REPLACE TRIGGER DATA_FILTER_ORDER
BEFORE INSERT
ON ORDER_TABLE
FOR EACH ROW    --INSERT ALL 대비로 여러 행이 검증될 수 있도록
BEGIN
    IF(:NEW.ORD_CODE) NOT IN ('C001') THEN  --새로운 값이 ORD_CODE에 들어갈텐데, COO1 아니라면
        RAISE_APPLICATION_ERROR(-20300, '무효한 제품 코드');
    END IF;
END;
/

INSERT INTO ORDER_TABLE VALUES(1, 'C001', SYSDATE);
INSERT INTO ORDER_TABLE VALUES(2, 'C002', SYSDATE);

--3.BACKUP TABLE 관리 TRIGGER -- 삭제한 값에 대한 보관은 백업 테이블에서 보관
--원본 TABLE : ORDER_TABLE
--백업 TABLE : BACKUP_ORDER

DROP TABLE ORDER_TABLE;

CREATE TABLE ORDER_TABLE(
	NO NUMBER,
	ORD_CODE VARCHAR2(10),
	ORD_DATE DATE
);

DROP TABLE BACKUP_ORDER;
CREATE TABLE BACKUP_ORDER( -- 백업 테이블
	NO NUMBER,
	ORD_CODE VARCHAR2(10),
	ORD_DATE DATE -- 원본 테이블에서 삭제된 시간, 원본 테이블과 다른 점
);

DROP TRIGGER BACKUP_TRIGGER;
CREATE OR REPLACE TRIGGER BACKUP_TRIGGER
BEFORE UPDATE
ON
    ORDER_TABLE
FOR EACH ROW
BEGIN
    INSERT INTO BACKUP_ORDER VALUES(:OLD.NO, :OLD.ORD_CODE, :OLD.ORD_DATE);
    --업데이트로 사라지는 값들을 백업테이블로 INSERT
END;
/

SELECT * FROM ORDER_TABLE;
INSERT INTO ORDER_TABLE VALUES(1, 'C001', SYSDATE);
SELECT * FROM BACKUP_ORDER;

UPDATE ORDER_TABLE SET ORD_CODE = 'C002' WHERE NO=1;

--4.?기존 TABLE의 데이터 DELETE시 BACKUP TABLE에 데이터 저장
--원본 TABLE : ORDER_TABLE2
--백업 TABLE : BACKUP_ORDER2
DROP TABLE BACKUP_ORDER2;
DROP TABLE BACKUP_ORDER2;

CREATE TABLE ORDER_TABLE2(
	NO NUMBER,
	ORD_CODE VARCHAR2(10)
);

--백업 TABLE에 추가된 컬럼 : 삭제 시점
CREATE TABLE BACKUP_ORDER2(
	NO NUMBER,
	ORD_CODE VARCHAR2(10),
	TIME DATE
);

SELECT * FROM ORDER_TABLE2;
SELECT * FROM BACKUP_ORDER2;

INSERT INTO ORDER_TABLE2 VALUES(1,'C001');

DROP BACKUP_TRIGGER_DELETE;
CREATE OR REPLACE TRIGGER BACKUP_TRIGGER_DELETE
BEFORE DELETE
ON
    ORDER_TABLE2
FOR EACH ROW
BEGIN
    INSERT INTO BACKUP_ORDER2 VALUES(:OLD.NO, :OLD.ORD_CODE, SYSDATE);
END;
/

DELETE FROM ORDER_TABLE2 WHERE NO = 1;

SELECT * FROM ORDER_TABLE2;
SELECT * FROM BACKUP_ORDER2;

--5. 트리거 관련 문제 만들기

DROP TABLE OT1;
DROP TABLE BT1;

CREATE TABLE OT1(
    NO NUMBER,
    CODE VARCHAR2(10),
    TIME DATE);
CREATE TABLE BT1 AS SELECT * FROM OT1 WHERE 1=0;

CREATE OR REPLACE TRIGGER OT_DELETE
BEFORE DELETE
ON
    OT1
FOR EACH ROW
BEGIN
    INSERT INTO BT1 VALUES (:OLD.NO, :OLD.CODE, SYSDATE);
END;
/

INSERT INTO OT1 VALUES (1, 'A1', SYSDATE);
INSERT INTO OT1 VALUES (1, 'B1', SYSDATE);
SELECT * FROM OT1;

DELETE FROM OT1 WHERE NO = 1;

SELECT * FROM BT1;


--

CREATE TABLE DEPT_COPY(DEPTNO, DNAME, LOC) AS SELECT DEPTNO, DNAME, LOC FROM DEPT;

SELECT * FROM TAB;